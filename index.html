<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Neo Sky Ace: OVERDRIVE</title>
  <style>
    html,body{margin:0;height:100%;background:#040711;color:#fff;font-family:-apple-system,system-ui,Segoe UI,Roboto}
    canvas{display:block;margin:0 auto;touch-action:none}
    #ui{position:fixed;inset:0;pointer-events:none}
    #top{display:flex;justify-content:space-between;gap:8px;padding:10px}
    .pill{pointer-events:none;background:rgba(10,18,35,.55);border:1px solid rgba(120,170,255,.18);
      padding:6px 10px;border-radius:999px;backdrop-filter:blur(10px);font-size:13px;opacity:.95}
    #bottom{position:fixed;left:0;right:0;bottom:0;display:flex;justify-content:space-between;align-items:flex-end;
      padding:10px;gap:10px;pointer-events:none}
    .btn{pointer-events:auto;user-select:none;-webkit-user-select:none;touch-action:manipulation;
      background:rgba(10,18,35,.6);border:1px solid rgba(120,170,255,.22);color:#fff;border-radius:14px;
      padding:10px 12px;font-size:14px}
    .btn:active{transform:scale(.98)}
    #skill{width:64px;height:64px;border-radius:999px;font-weight:700}
    #joyWrap{pointer-events:auto;width:140px;height:140px;position:relative}
    #joyBase{position:absolute;inset:0;border-radius:999px;border:1px solid rgba(120,170,255,.22);
      background:rgba(10,18,35,.35);backdrop-filter:blur(10px)}
    #joyKnob{position:absolute;left:50%;top:50%;width:64px;height:64px;transform:translate(-50%,-50%);
      border-radius:999px;border:1px solid rgba(120,170,255,.30);background:rgba(122,166,255,.18)}
    #modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.60);backdrop-filter:blur(10px)}
    #panel{width:min(92vw,560px);background:rgba(9,14,28,.92);border:1px solid rgba(120,170,255,.22);
      border-radius:18px;padding:14px}
    #panel h2{margin:6px 0 10px;font-size:18px}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .card{flex:1 1 160px;background:rgba(255,255,255,.04);border:1px solid rgba(120,170,255,.16);
      border-radius:14px;padding:10px;cursor:pointer}
    .card small{opacity:.8;line-height:1.25}
    .tag{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid rgba(120,170,255,.22);opacity:.85;font-size:12px;margin-left:6px}
    .hint{opacity:.78;font-size:13px;margin-top:10px;line-height:1.35}
    #pick{margin-top:10px}
    #pick .card{flex:1 1 140px}
  </style>
</head>
<body>
<canvas id="c" width="390" height="720"></canvas>

<div id="ui">
  <div id="top">
    <div class="pill">å…³å¡ <b id="lvl">1</b> Â· æ³¢æ¬¡ <b id="wave">1</b> <span class="tag" id="bossTag" style="display:none">BOSS</span></div>
    <div class="pill">åˆ†æ•° <b id="score">0</b> Â· è¿å‡» <b id="combo">x1</b></div>
    <div class="pill">HP <b id="hp">100</b> Â· æŠ¤ç›¾ <b id="sh">0</b> Â· èƒ½é‡ <b id="en">0</b></div>
  </div>

  <div id="bottom">
    <div id="joyWrap">
      <div id="joyBase"></div>
      <div id="joyKnob"></div>
    </div>

    <div style="display:flex;gap:10px;align-items:flex-end;pointer-events:none">
      <button class="btn" id="pause" style="pointer-events:auto">æš‚åœ</button>
      <button class="btn" id="cheat" style="pointer-events:auto">ä½œå¼Šï¼šå…³</button>
      <button class="btn" id="skill" style="pointer-events:auto">âš¡</button>
    </div>
  </div>
</div>

<div id="modal">
  <div id="panel">
    <h2>Neo Sky Ace: OVERDRIVE <span class="tag">å·¦ä¸‹æ‘‡æ†ç§»åŠ¨ Â· è‡ªåŠ¨å¼€ç« Â· å³ä¸‹æŠ€èƒ½</span></h2>
    <div class="row" id="planes"></div>

    <div class="hint">
      <b>å‡çº§ç³»ç»Ÿï¼ˆæ›´ç‰›çš„æ ¸å¿ƒï¼‰ï¼š</b>æ‰“åˆ°ä¸€å®šè¿›åº¦ä¼šå¼¹å‡ºâ€œä¸‰é€‰ä¸€â€å¼ºåŒ–ï¼ˆRogueliteï¼‰ï¼Œè¶Šæ‰“è¶Šå¼ºã€‚<br/>
      <b>Bossï¼š</b>æ¯ 5 å…³ä¸€ä¸ª Bossï¼Œå¤šé˜¶æ®µï¼šæŠ¤ç›¾/æ¿€å…‰æ‰«å°„/è¿½è¸ªå¯¼å¼¹/å¼¹å¹•çˆ†å‘ã€‚<br/>
      <b>ä½œå¼Šæ¨¡å¼ï¼š</b>æ— æ•Œ + è¶…ç«åŠ› + æ•Œäººæ…¢åŠ¨ä½œ + è‡ªåŠ¨å¸é“å…·ï¼ˆçˆ½ç©/æµ‹è¯•ï¼‰
    </div>

    <div style="display:flex;gap:10px;margin-top:12px;justify-content:flex-end">
      <button class="btn" id="start">å¼€å§‹</button>
    </div>

    <div id="pick" style="display:none">
      <h2 style="margin-top:12px">é€‰æ‹©å¼ºåŒ–ï¼ˆä¸‰é€‰ä¸€ï¼‰</h2>
      <div class="row" id="upgrades"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // ====== é€»è¾‘å°ºå¯¸ ======
  const W = 390, H = 720;
  function fit(){
    const maxW = Math.min(window.innerWidth, 560);
    const scale = maxW / W;
    canvas.style.width = (W * scale) + 'px';
    canvas.style.height = (H * scale) + 'px';
  }
  window.addEventListener('resize', fit); fit();

  // ====== UI refs ======
  const ui = {
    lvl: document.getElementById('lvl'),
    wave: document.getElementById('wave'),
    score: document.getElementById('score'),
    combo: document.getElementById('combo'),
    hp: document.getElementById('hp'),
    sh: document.getElementById('sh'),
    en: document.getElementById('en'),
    bossTag: document.getElementById('bossTag'),
    modal: document.getElementById('modal'),
    planes: document.getElementById('planes'),
    start: document.getElementById('start'),
    pause: document.getElementById('pause'),
    cheat: document.getElementById('cheat'),
    skill: document.getElementById('skill'),
    pickWrap: document.getElementById('pick'),
    upgrades: document.getElementById('upgrades'),
    joyWrap: document.getElementById('joyWrap'),
    joyKnob: document.getElementById('joyKnob'),
  };

  // ====== helpers ======
  const rand=(a,b)=>a+Math.random()*(b-a);
  const randi=(a,b)=>Math.floor(rand(a,b+1));
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist2=(ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by; return dx*dx+dy*dy;};
  const hitC=(ax,ay,ar,bx,by,br)=>dist2(ax,ay,bx,by) <= (ar+br)*(ar+br);

  // ====== audio (tiny) ======
  let audioOK=false;
  const actx = new (window.AudioContext || window.webkitAudioContext)();
  function beep(freq=440,dur=0.05,type='sine',gain=0.04){
    if(!audioOK) return;
    const o=actx.createOscillator(), g=actx.createGain();
    o.type=type; o.frequency.value=freq;
    g.gain.value=gain;
    o.connect(g); g.connect(actx.destination);
    o.start(); o.stop(actx.currentTime+dur);
  }

  // ====== planes (with unlock) ======
  const PLANE_TYPES = [
    { id:'RAPTOR', name:'Raptor',  desc:'å‡è¡¡ Â· è¿å°„ç¨³å®š', hp:110, speed:1.00, fire:0.12, dmg:10, spread:0.08 },
    { id:'VIPER',  name:'Viper',   desc:'é«˜é€Ÿ Â· åŒå‘',     hp:95,  speed:1.20, fire:0.14, dmg:9,  spread:0.10 },
    { id:'PHANTOM',name:'Phantom', desc:'é‡è£… Â· é«˜ä¼¤æ…¢å°„', hp:135, speed:0.92, fire:0.18, dmg:14, spread:0.06 },
    { id:'NEBULA', name:'Nebula',  desc:'æ•£å°„ Â· æ¸…å±å¼º',   hp:105, speed:1.02, fire:0.16, dmg:9,  spread:0.24 },
    { id:'ION',    name:'ION',     desc:'ç©¿é€ Â· ç ´ç›¾å¿«',   hp:100, speed:1.05, fire:0.13, dmg:10, spread:0.06, pierce:true, unlock:8 },
    { id:'AURORA', name:'Aurora',  desc:'æš´å‡» Â· çˆ†å‘é«˜',   hp:108, speed:1.00, fire:0.12, dmg:10, spread:0.08, crit:true, unlock:12 },
  ];
  const saveKey = 'neo_sky_ace_save_v2';
  const save = JSON.parse(localStorage.getItem(saveKey)||'{}');
  save.bestLevel = save.bestLevel || 1;
  localStorage.setItem(saveKey, JSON.stringify(save));

  // ====== game state ======
  let running=false, paused=false, cheat=false;
  let score=0, combo=1, comboT=0;
  let level=1, wave=1;
  let bossAlive=false;
  let lastT=performance.now();

  // entities
  let stars=[], particles=[], bullets=[], eBullets=[], enemies=[], drops=[], flashes=[];
  const camera={sx:0,sy:0,shakeT:0,shakeP:0};

  // ====== player ======
  const player = {
    x: W/2, y: H-110, r:16,
    hp: 110, hpMax:110,
    sh: 0, // seconds
    en: 0, // 0..100
    power: 1, // 1..8
    missiles: 1,
    invul: 0.8,
    fireCD: 0,
    skillCD: 0,
    plane: PLANE_TYPES[0],
    // roguelite stats
    lifesteal: 0, // %
    magnet: 0,    // attraction strength
    drone: 0,     // drone count
    crit: 0,      // extra crit chance
    pierce: 0,    // piercing count
    slow: 0,      // enemy slow %
  };

  // ====== background ======
  function initStars(){
    stars=[];
    for(let i=0;i<100;i++){
      stars.push({x:Math.random()*W,y:Math.random()*H,s:rand(0.5,1.8),v:rand(10,90)});
    }
  }
  initStars();

  function addParticle(x,y,n=12,spd=240,life=0.55){
    for (let i=0;i<n;i++){
      const a=rand(0,Math.PI*2);
      const s=rand(spd*0.2, spd);
      particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,r:rand(1,2.4),life,ttl:life});
    }
  }
  function flash(a=0.22){ flashes.push({a,life:0.12,ttl:0.12}); }
  function shake(t=0.12,p=6){ camera.shakeT=Math.max(camera.shakeT,t); camera.shakeP=Math.max(camera.shakeP,p); }

  // ====== joystick ======
  let joyActive=false;
  let joyCenter=null;
  let joyVec={x:0,y:0}; // -1..1
  function setJoyKnob(nx,ny){
    const max=42;
    ui.joyKnob.style.transform = `translate(${nx*max-32}px,${ny*max-32}px)`; // knob is 64x64, base is centered
  }
  function resetJoy(){
    joyVec.x=0; joyVec.y=0;
    ui.joyKnob.style.transform = `translate(-32px,-32px)`;
  }
  // init knob position center
  ui.joyKnob.style.left='50%'; ui.joyKnob.style.top='50%';
  ui.joyKnob.style.transform='translate(-32px,-32px)';

  function joyPosFromTouch(t){
    const rect=ui.joyWrap.getBoundingClientRect();
    const x=t.clientX-rect.left;
    const y=t.clientY-rect.top;
    return {x,y,rect};
  }

  ui.joyWrap.addEventListener('touchstart',(e)=>{
    audioOK=true; actx.resume?.();
    joyActive=true;
    const t=e.touches[0];
    const p=joyPosFromTouch(t);
    joyCenter={x:p.rect.width/2,y:p.rect.height/2, rect:p.rect};
    e.preventDefault();
  },{passive:false});
  ui.joyWrap.addEventListener('touchmove',(e)=>{
    if(!joyActive) return;
    const t=e.touches[0];
    const p=joyPosFromTouch(t);
    const dx=p.x-joyCenter.x, dy=p.y-joyCenter.y;
    const len=Math.hypot(dx,dy);
    const max=52;
    const nx = len>0 ? clamp(dx/max,-1,1) : 0;
    const ny = len>0 ? clamp(dy/max,-1,1) : 0;
    joyVec.x=nx; joyVec.y=ny;
    setJoyKnob(nx,ny);
    e.preventDefault();
  },{passive:false});
  ui.joyWrap.addEventListener('touchend',()=>{
    joyActive=false; joyCenter=null;
    resetJoy();
  });

  // ====== buttons ======
  ui.pause.onclick=()=>{ paused=!paused; ui.pause.textContent=paused?'ç»§ç»­':'æš‚åœ'; };
  ui.cheat.onclick=()=>{ cheat=!cheat; ui.cheat.textContent=cheat?'ä½œå¼Šï¼šå¼€':'ä½œå¼Šï¼šå…³'; flash(cheat?0.35:0.18); };
  ui.skill.onclick=()=>{ castSkill(); };

  // ====== enemies ======
  const ENEMY = {
    SCOUT:   { hp:22, r:14, v:105, score:30,  col:'#ff5b7e' },
    DIVE:    { hp:30, r:14, v:175, score:44,  col:'#ff7a5b' },
    SINE:    { hp:40, r:16, v:120, score:64,  col:'#ff5bda' },
    GUNNER:  { hp:60, r:18, v:90,  score:98,  col:'#ffcb4a' },
    TANK:    { hp:110,r:22, v:70,  score:170, col:'#5bffb3' },
    SPLITTER:{ hp:52, r:16, v:105, score:86,  col:'#a78bff' },
    TURRET:  { hp:80, r:19, v:55,  score:120, col:'#7aa6ff' },
    CARRIER: { hp:140,r:24, v:60,  score:240, col:'#ff9ad6' },
    BOSS:    { hp:900,r:44, v:52,  score:2000,col:'#8be9ff' },
  };

  function spawnEnemy(type, x=null, y=null){
    const t=ENEMY[type];
    const e={
      type,
      x: x??rand(30,W-30),
      y: y??(-60),
      r:t.r,
      hp:t.hp, hpMax:t.hp,
      v:t.v,
      col:t.col,
      seed:Math.random()*10,
      phase:0,
      shootCD:rand(0.5,1.1),
      aux:0,
      // boss props
      shield: (type==='BOSS')? 240 : 0, // shield hp
      stage: 1,
      laserT: 0,
      missileT: 0,
      burstT: 0
    };
    enemies.push(e);
  }

  function fireEnemy(e){
    const slowMul = 1 - (player.slow||0);
    const timeMul = (cheat?0.55:1.0) * slowMul;
    const base = (e.type==='BOSS')? 240 : (e.type==='GUNNER'? 185 : 165);
    const sp = base * timeMul;

    const dx=player.x-e.x, dy=player.y-e.y;
    const len=Math.max(1,Math.hypot(dx,dy));
    const ux=dx/len, uy=dy/len;

    if(e.type==='BOSS'){
      // spiral-ish burst
      const n = 11;
      const ang0 = Math.atan2(uy,ux);
      const step = 0.14;
      for(let i=0;i<n;i++){
        const a = ang0 + (i-(n-1)/2)*step;
        eBullets.push({x:e.x,y:e.y+18,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,r:4.6,dmg:12,life:3});
      }
      beep(160,0.06,'sawtooth',0.03);
      return;
    }

    if(e.type==='TURRET'){
      // 3-way
      const a0=Math.atan2(uy,ux);
      for(const da of [-0.18,0,0.18]){
        const a=a0+da;
        eBullets.push({x:e.x,y:e.y+10,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,r:4.2,dmg:9,life:2.8});
      }
      beep(200,0.05,'square',0.02);
      return;
    }

    eBullets.push({x:e.x,y:e.y+10,vx:ux*sp,vy:uy*sp,r:4.2,dmg:(e.type==='GUNNER'?10:8),life:2.8});
    beep(230,0.04,'sawtooth',0.02);
  }

  // ====== drops ======
  const DROP = [
    {k:'POWER',p:0.32},{k:'SHIELD',p:0.18},{k:'MISSILE',p:0.18},{k:'ENERGY',p:0.22},{k:'HP',p:0.10}
  ];
  function maybeDrop(x,y){
    if(Math.random()>0.35) return;
    let r=Math.random(), s=0, kind='POWER';
    for(const d of DROP){ s+=d.p; if(r<=s){ kind=d.k; break; } }
    drops.push({x,y,kind,r:12,v:70,life:12});
  }
  function applyDrop(k){
    if(k==='POWER'){ player.power=clamp(player.power+1,1,8); flash(0.12); beep(1200,0.05,'triangle',0.04); }
    if(k==='SHIELD'){ player.sh=Math.max(player.sh,5); flash(0.10); beep(980,0.05,'sine',0.04); }
    if(k==='MISSILE'){ player.missiles=clamp(player.missiles+1,0,8); beep(640,0.05,'square',0.035); }
    if(k==='ENERGY'){ player.en=clamp(player.en+30,0,100); beep(520,0.05,'sine',0.035); }
    if(k==='HP'){ player.hp=clamp(player.hp+18,0,player.hpMax); beep(420,0.05,'sine',0.035); }
    addParticle(player.x,player.y,16,260,0.45);
  }

  // ====== roguelite upgrades ======
  const UPG_POOL = [
    {id:'FIRE',   name:'è¶…é¢‘å°„é€Ÿ', desc:'å°„é€Ÿ +18%ï¼ˆå åŠ ï¼‰', apply:()=>{ player.plane.fire*=0.82; }},
    {id:'DMG',    name:'é«˜èƒ½ç‚®ç®¡', desc:'å­å¼¹ä¼¤å®³ +2', apply:()=>{ player.plane.dmg+=2; }},
    {id:'MAG',    name:'ç£å¸ç»„ä»¶', desc:'è‡ªåŠ¨å¸é“å…·æ›´å¼º', apply:()=>{ player.magnet = clamp((player.magnet||0)+0.6,0,3); }},
    {id:'DRONE',  name:'åƒšæœºæ— äººæœº', desc:'è·å¾— 1 ä¸ªæ— äººæœºï¼ˆæœ€å¤š3ï¼‰', apply:()=>{ player.drone=clamp((player.drone||0)+1,0,3); }},
    {id:'LIFEST', name:'èƒ½é‡è™¹å¸', desc:'å‡»æ€å›å¤ 2% HP', apply:()=>{ player.lifesteal = clamp((player.lifesteal||0)+2,0,10); }},
    {id:'CRIT',   name:'æš´å‡»ç”µå®¹', desc:'æš´å‡»ç‡ +6%ï¼ˆæœ€å¤š30%ï¼‰', apply:()=>{ player.crit = clamp((player.crit||0)+6,0,30); }},
    {id:'PIERCE', name:'ç©¿é€å¼¹èŠ¯', desc:'å­å¼¹ç©¿é€ +1ï¼ˆæœ€å¤š2ï¼‰', apply:()=>{ player.pierce = clamp((player.pierce||0)+1,0,2); }},
    {id:'SLOW',   name:'å¼•åŠ›åœº', desc:'æ•Œäººæ•´ä½“å‡é€Ÿ 10%ï¼ˆæœ€å¤š30%ï¼‰', apply:()=>{ player.slow = clamp((player.slow||0)+0.10,0,0.30); }},
    {id:'HPUP',   name:'è£…ç”²å‡çº§', desc:'æœ€å¤§HP +12', apply:()=>{ player.hpMax+=12; player.hp+=12; }},
    {id:'MISS',   name:'å¯¼å¼¹è¡¥ç»™', desc:'å¯¼å¼¹ +2', apply:()=>{ player.missiles=clamp(player.missiles+2,0,8); }},
  ];
  let nextUpgradeScore = 600;

  function showUpgradePick(){
    paused=true;
    ui.pause.textContent='ç»§ç»­';
    ui.modal.style.display='flex';
    ui.pickWrap.style.display='block';
    ui.upgrades.innerHTML='';

    // pick 3 distinct
    const opts=[];
    while(opts.length<3){
      const o = UPG_POOL[randi(0,UPG_POOL.length-1)];
      if(!opts.find(x=>x.id===o.id)) opts.push(o);
    }
    opts.forEach(o=>{
      const div=document.createElement('div');
      div.className='card';
      div.innerHTML=`<b>${o.name}</b><br/><small>${o.desc}</small>`;
      div.onclick=()=>{
        o.apply();
        beep(960,0.05,'triangle',0.04);
        ui.pickWrap.style.display='none';
        ui.modal.style.display='none';
        paused=false; ui.pause.textContent='æš‚åœ';
        nextUpgradeScore = Math.round(nextUpgradeScore * 1.55);
      };
      ui.upgrades.appendChild(div);
    });
  }

  // ====== firing ======
  function firePlayer(){
    const p=player.plane;
    const base=360;
    const power=cheat?8:player.power;
    const spread=p.spread + (power-1)*0.05;
    let dmg = p.dmg + (power-1)*1.4 + (cheat?8:0);

    const critChance = (p.crit?8:0) + (player.crit||0);
    const doCrit = ()=> (Math.random()*100) < critChance;

    const lanes = Math.min(1+Math.floor(power/2), 5);
    const pierceBase = (p.pierce?1:0) + (player.pierce||0);

    for(let i=0;i<lanes;i++){
      const off=(i-(lanes-1)/2)*10;
      const ang=rand(-spread,spread);
      const crit=doCrit();
      bullets.push({
        x:player.x+off,y:player.y-player.r-6,
        vx:Math.sin(ang)*90, vy:-base,
        r:4, dmg: crit? dmg*1.75 : dmg,
        pierce: pierceBase,
        life:1.25
      });
      if(crit) addParticle(player.x+off, player.y-20, 6, 220, 0.25);
    }

    // Nebula / cheat extra spray
    if(p.id==='NEBULA' || cheat){
      const extra=Math.max(0,power-2);
      for(let k=0;k<extra;k++){
        const ang=rand(-0.7,0.7);
        bullets.push({x:player.x,y:player.y-24,vx:Math.sin(ang)*230,vy:-base*0.82,r:3.2,dmg:Math.max(7,dmg-3),pierce:0,life:0.95});
      }
    }

    // drones
    if((player.drone||0)>0){
      for(let d=0; d<player.drone; d++){
        const dx = (d-(player.drone-1)/2)*22;
        bullets.push({x:player.x+dx,y:player.y-18,vx:0,vy:-320,r:3.4,dmg:Math.max(7,dmg-4),pierce:0,life:0.9});
      }
    }

    beep(880,0.02,'square',0.02);
  }

  function castSkill(){
    if(player.skillCD>0) return;
    // âš¡æŠ€èƒ½ï¼šæ¶ˆè€—èƒ½é‡ or cheat free
    if(!cheat && player.en < 70) { flash(0.08); return; }
    if(!cheat) player.en -= 70;

    player.skillCD = 3.8;
    flash(0.40); shake(0.25,10);
    // å…¨å±ç”µå¼§ï¼šå¯¹æ•Œäººé€ æˆé«˜é¢ä¼¤å®³ï¼Œä¸”æ‰“æ‰æŠ¤ç›¾æ›´æ˜æ˜¾
    for(const e of enemies){
      if(e.type==='BOSS'){
        if(e.shield>0) e.shield -= 220;
        e.hp -= 160;
      } else {
        e.hp -= 170;
      }
      addParticle(e.x,e.y,26,380,0.55);
    }
    beep(140,0.12,'sawtooth',0.06);
  }

  function castMissile(){
    if(player.missiles<=0) return;
    player.missiles--;
    // æ‰¾æœ€è¿‘æ•Œäºº
    let best=null, bd=1e18;
    for(const e of enemies){
      const d=dist2(player.x,player.y,e.x,e.y);
      if(d<bd){ bd=d; best=e; }
    }
    if(!best) return;
    // ç”Ÿæˆè¿½è¸ªå¯¼å¼¹å®ä½“ï¼ˆç”¨å­å¼¹æ¨¡æ‹Ÿï¼Œå¸¦è½¬å‘ï¼‰
    bullets.push({x:player.x,y:player.y-20,vx:0,vy:-220,r:5.5,dmg:120,life:2.0,homing:true,target:best,pierce:0});
    beep(520,0.06,'square',0.03);
  }

  // åŒå‡»ç”»é¢ï¼šå¯¼å¼¹ï¼ˆæ›´çˆ½ï¼‰
  let tapT=0;
  canvas.addEventListener('touchend',()=>{
    const t=performance.now();
    if(t-tapT<260){ castMissile(); tapT=0; }
    else tapT=t;
  });

  // ====== stage system (procedural) ======
  // æ¯å…³ 3 æ³¢ï¼Œç¬¬ 3 æ³¢å¦‚æœæ˜¯ 5 çš„å€æ•° -> Boss
  function wavePlan(level, wave){
    const boss = (wave===3 && level%5===0);
    if(boss) return {dur: 20, sp: 0.95, boss:true};
    // ç»„åˆéšå…³å¡å¢é•¿
    const hard = Math.min(1, (level-1)/14);
    const sp = 0.62 - hard*0.18 - (wave-1)*0.04;
    const dur = 16 + wave*2 + level*0.6;
    return {dur, sp: Math.max(0.34, sp), boss:false};
  }

  function mixFor(level){
    const pool=['SCOUT','DIVE','SINE','GUNNER','SPLITTER','TURRET','TANK','CARRIER'];
    const maxIdx = clamp(2 + Math.floor(level/2), 2, pool.length-1);
    return pool.slice(0, maxIdx+1);
  }

  let waveT=0, spawnT=0;

  function spawnLogic(dt){
    const plan = wavePlan(level, wave);
    ui.bossTag.style.display = plan.boss ? 'inline-block' : 'none';

    // boss wave: spawn boss once
    if(plan.boss){
      if(!bossAlive){
        bossAlive=true;
        spawnEnemy('BOSS', W/2, -120);
        flash(0.25);
      }
      // wave ends when boss dead
      if(!enemies.find(e=>e.type==='BOSS')){
        bossAlive=false;
        wave++;
        waveT=0; spawnT=0;
        if(wave>3){ wave=1; level++; save.bestLevel=Math.max(save.bestLevel, level); localStorage.setItem(saveKey, JSON.stringify(save)); flash(0.18); }
      }
      return;
    }

    waveT += dt;
    spawnT += dt;

    const sp = plan.sp * (cheat?1.15:1.0);
    if(spawnT >= sp){
      spawnT=0;
      const mix = mixFor(level);
      spawnEnemy(mix[randi(0,mix.length-1)]);
      if(level>=4 && Math.random()<0.12) spawnEnemy('SCOUT');
    }

    if(waveT >= plan.dur){
      wave++;
      waveT=0; spawnT=0;
      if(wave>3){ wave=1; level++; save.bestLevel=Math.max(save.bestLevel, level); localStorage.setItem(saveKey, JSON.stringify(save)); flash(0.18); }
    }
  }

  // ====== boss patterns ======
  function bossAI(e, dt){
    // 3 é˜¶æ®µï¼šç›¾ -> æ¿€å…‰æ‰«å°„ -> è¿½è¸ªå¯¼å¼¹/çˆ†å‘
    e.phase += dt;
    e.y += e.v*dt*0.55;
    e.x = W/2 + Math.sin(e.phase*0.7)*90;

    // keep boss on screen
    e.y = Math.min(e.y, 180);

    // stage changes
    if(e.shield<=0 && e.stage===1){ e.stage=2; flash(0.22); shake(0.12,8); }
    if(e.hp<= e.hpMax*0.45 && e.stage===2){ e.stage=3; flash(0.26); shake(0.14,10); }

    // shooting
    const slowMul = 1 - (player.slow||0);
    const timeMul = (cheat?0.60:1.0) * slowMul;

    e.shootCD -= dt*timeMul;
    if(e.shootCD<=0){
      e.shootCD = (e.stage===3? 0.42 : 0.55);
      fireEnemy(e);
    }

    // laser sweep stage2/3
    if(e.stage>=2){
      e.laserT -= dt*timeMul;
      if(e.laserT<=0){
        e.laserT = (e.stage===3? 2.2 : 2.8);
        // spawn a laser beam indicator (we'll draw & damage)
        eBullets.push({type:'LASER', x:e.x, y:e.y, a:0, w:14, t:1.25, life:1.25, dmg:18});
        beep(120,0.10,'sawtooth',0.03);
      }
    }

    // missiles stage3
    if(e.stage===3){
      e.missileT -= dt*timeMul;
      if(e.missileT<=0){
        e.missileT = 1.8;
        // 2 homing bullets
        for(let k=0;k<2;k++){
          eBullets.push({type:'HOM', x:e.x+rand(-18,18), y:e.y+20, vx:rand(-30,30), vy:180, r:5.2, dmg:12, life:3.0});
        }
      }
    }
  }

  // ====== reset / start ======
  function applyPlane(p){
    player.plane = {...p}; // copy so upgrades change only current run
    player.hpMax = p.hp; player.hp = p.hp;
    player.power=1; player.missiles=1;
    player.sh=0; player.en=0; player.invul=0.8;
    player.fireCD=0; player.skillCD=0;
    player.lifesteal=0; player.magnet=0; player.drone=0; player.crit=0; player.pierce=0; player.slow=0;
  }

  function hardReset(){
    score=0; combo=1; comboT=0;
    level=1; wave=1; bossAlive=false;
    bullets=[]; eBullets=[]; enemies=[]; drops=[]; particles=[]; flashes=[];
    initStars();
    player.x=W/2; player.y=H-110;
    player.invul=0.8; player.sh=0; player.en=0; player.fireCD=0; player.skillCD=0;
    waveT=0; spawnT=0;
    nextUpgradeScore=600;
    paused=false; ui.pause.textContent='æš‚åœ';
    running=true;
    syncUI();
  }

  // ====== selection UI ======
  let selected = PLANE_TYPES[0];
  function buildPlaneCards(){
    ui.planes.innerHTML='';
    PLANE_TYPES.forEach(p=>{
      const need = p.unlock || 1;
      const locked = save.bestLevel < need;
      const div=document.createElement('div');
      div.className='card';
      div.style.opacity = locked?0.45:1;
      div.innerHTML = `<b>${p.name}</b>${locked?` <span class="tag">è§£é”ï¼šå…³å¡${need}</span>`:''}
      <br/><small>${p.desc}</small>
      <div style="opacity:.82;margin-top:8px;font-size:12px">
        HP ${p.hp} Â· é€Ÿåº¦ ${p.speed.toFixed(2)} Â· å°„é€Ÿ ${(1/p.fire).toFixed(1)}/s
      </div>`;
      div.onclick=()=>{
        if(locked){ flash(0.08); beep(180,0.06,'square',0.02); return; }
        selected=p;
        [...ui.planes.children].forEach(c=>c.style.outline='none');
        div.style.outline='2px solid rgba(122,166,255,.7)';
      };
      ui.planes.appendChild(div);
    });
    ui.planes.children[0].style.outline='2px solid rgba(122,166,255,.7)';
  }
  buildPlaneCards();

  ui.start.onclick=()=>{
    ui.modal.style.display='none';
    ui.pickWrap.style.display='none';
    applyPlane(selected);
    hardReset();
    audioOK=true; actx.resume?.();
  };

  // ====== update & draw ======
  function syncUI(){
    ui.lvl.textContent=level;
    ui.wave.textContent=wave;
    ui.score.textContent=score;
    ui.combo.textContent='x'+combo.toFixed(1).replace('.0','');
    ui.hp.textContent=Math.max(0,Math.round(player.hp));
    ui.sh.textContent=Math.round(player.sh);
    ui.en.textContent=Math.round(player.en);
    ui.skill.textContent = player.skillCD>0 ? `âš¡${player.skillCD.toFixed(1)}` : 'âš¡';
  }

  function update(dt){
    if(!running || paused) return;

    // stars
    for(const s of stars){
      s.y += s.v*dt*(cheat?0.65:1);
      if(s.y>H+10){ s.y=-10; s.x=Math.random()*W; s.v=rand(10,90); s.s=rand(0.5,1.8); }
    }

    // camera shake
    if(camera.shakeT>0){
      camera.shakeT -= dt;
      const p=camera.shakeP;
      camera.sx=rand(-p,p); camera.sy=rand(-p,p);
      if(camera.shakeT<=0){ camera.sx=0; camera.sy=0; camera.shakeP=0; }
    }

    // player status
    player.invul = Math.max(0, player.invul-dt);
    player.sh = Math.max(0, player.sh-dt);
    player.skillCD = Math.max(0, player.skillCD-dt);

    // movement by joystick
    const spd = 260 * player.plane.speed;
    player.x = clamp(player.x + joyVec.x*spd*dt, player.r, W-player.r);
    player.y = clamp(player.y + joyVec.y*spd*dt, player.r+40, H-player.r);

    // auto fire
    player.fireCD -= dt;
    const fireRate = cheat ? 0.06 : player.plane.fire;
    if(player.fireCD<=0){
      player.fireCD = fireRate;
      firePlayer();
    }

    // spawn progression
    spawnLogic(dt);

    // bullets
    for(const b of bullets){
      if(b.homing && b.target && b.target.hp>0){
        const dx=b.target.x-b.x, dy=b.target.y-b.y;
        const len=Math.max(1,Math.hypot(dx,dy));
        const ux=dx/len, uy=dy/len;
        b.vx = b.vx*0.88 + ux*260*0.12;
        b.vy = b.vy*0.88 + uy*260*0.12;
      }
      b.x += b.vx*dt;
      b.y += b.vy*dt;
      b.life -= dt;
    }
    bullets = bullets.filter(b=>b.life>0 && b.y>-120 && b.y<H+120 && b.x>-120 && b.x<W+120);

    // enemy bullets
    for(const b of eBullets){
      if(b.type==='LASER'){
        b.life -= dt;
        // rotate
        b.a += dt*1.6;
      } else if(b.type==='HOM'){
        // home towards player
        const dx=player.x-b.x, dy=player.y-b.y;
        const len=Math.max(1,Math.hypot(dx,dy));
        const ux=dx/len, uy=dy/len;
        b.vx = (b.vx||0)*0.86 + ux*220*0.14;
        b.vy = (b.vy||0)*0.86 + uy*220*0.14;
        b.x += b.vx*dt; b.y += b.vy*dt;
        b.life -= dt;
      } else {
        b.x += b.vx*dt; b.y += b.vy*dt;
        b.life -= dt;
      }
    }
    eBullets = eBullets.filter(b=>b.life>0);

    // enemies
    const slowMul = 1 - (player.slow||0);
    const timeMul = (cheat?0.55:1.0) * slowMul;

    for(const e of enemies){
      e.phase += dt;

      if(e.type==='BOSS'){
        bossAI(e, dt);
      } else if(e.type==='DIVE'){
        e.y += e.v*dt*timeMul;
        e.x += Math.sin(e.phase*6+e.seed)*120*dt;
      } else if(e.type==='SINE'){
        e.y += e.v*dt*timeMul;
        e.x += Math.sin(e.phase*2.6+e.seed)*170*dt;
      } else if(e.type==='GUNNER'){
        e.y += e.v*dt*0.78*timeMul;
        e.x += Math.sin(e.phase*2+e.seed)*80*dt;
        e.shootCD -= dt*timeMul;
        if(e.shootCD<=0){ e.shootCD=rand(0.65,1.1); fireEnemy(e); }
      } else if(e.type==='TANK'){
        e.y += e.v*dt*0.62*timeMul;
        e.x += Math.sin(e.phase*1.6+e.seed)*60*dt;
        e.shootCD -= dt*timeMul;
        if(e.shootCD<=0){ e.shootCD=rand(0.55,0.9); fireEnemy(e); }
      } else if(e.type==='SPLITTER'){
        e.y += e.v*dt*timeMul;
        e.x += Math.sin(e.phase*3.2+e.seed)*120*dt;
        e.shootCD -= dt*timeMul;
        if(e.shootCD<=0){ e.shootCD=rand(0.8,1.3); fireEnemy(e); }
      } else if(e.type==='TURRET'){
        e.y += e.v*dt*0.55*timeMul;
        e.x += Math.sin(e.phase*1.2+e.seed)*50*dt;
        e.shootCD -= dt*timeMul;
        if(e.shootCD<=0){ e.shootCD=rand(0.75,1.1); fireEnemy(e); }
      } else if(e.type==='CARRIER'){
        e.y += e.v*dt*0.62*timeMul;
        e.x += Math.sin(e.phase*1.0+e.seed)*55*dt;
        // carrier spawns scouts
        e.aux -= dt*timeMul;
        if(e.aux<=0){
          e.aux = rand(1.0,1.6);
          spawnEnemy('SCOUT', e.x+rand(-20,20), e.y+rand(10,20));
        }
        e.shootCD -= dt*timeMul;
        if(e.shootCD<=0){ e.shootCD=rand(0.9,1.4); fireEnemy(e); }
      } else { // SCOUT
        e.y += e.v*dt*timeMul;
      }

      if(e.y>H+120) e.hp=0;
    }

    // particles
    for(const p of particles){
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.vx *= Math.pow(0.08,dt);
      p.vy *= Math.pow(0.08,dt);
      p.life -= dt;
    }
    particles = particles.filter(p=>p.life>0);

    // flashes
    for(const f of flashes) f.life -= dt;
    flashes = flashes.filter(f=>f.life>0);

    // drops with magnet
    for(const d of drops){
      d.y += d.v*dt;
      d.life -= dt;
      const a=dist2(d.x,d.y,player.x,player.y);
      const mag = (cheat?2.2:0.9) + (player.magnet||0);
      if(a<160*160){
        d.x += (player.x-d.x)*dt*mag;
        d.y += (player.y-d.y)*dt*mag;
      }
    }
    drops = drops.filter(d=>d.life>0 && d.y<H+60);

    // collisions: player bullets -> enemies
    for(const b of bullets){
      for(const e of enemies){
        if(e.hp<=0) continue;
        if(hitC(b.x,b.y,b.r,e.x,e.y,e.r)){
          // boss shield first
          if(e.type==='BOSS' && e.shield>0){
            e.shield -= b.dmg;
            addParticle(b.x,b.y,10,280,0.35);
            b.life = 0;
          } else {
            e.hp -= b.dmg;
            addParticle(b.x,b.y,10,280,0.35);

            // piercing
            if((b.pierce||0)>0){
              b.pierce--;
              // do not kill bullet immediately
              b.life = Math.max(b.life, 0.05);
            } else {
              b.life = 0;
            }

            // energy gain
            player.en = clamp(player.en + 1.6, 0, 100);
          }

          if(e.hp<=0){
            // splitters split
            if(e.type==='SPLITTER'){
              for(let k=0;k<2;k++) spawnEnemy('SCOUT', e.x+rand(-18,18), e.y+rand(-6,6));
            }
            score += Math.round((ENEMY[e.type].score||60) * combo);
            comboT = 2.2;
            combo = clamp(combo + 0.12, 1, 10);
            maybeDrop(e.x,e.y);
            addParticle(e.x,e.y,26,380,0.6);
            flash(0.08);
            if(e.type==='BOSS') { shake(0.25,14); flash(0.22); }
            // lifesteal
            if(player.lifesteal>0){
              player.hp = clamp(player.hp + player.hpMax*(player.lifesteal/100), 0, player.hpMax);
            }
            beep(160,0.05,'square',0.04);
          }
          break;
        }
      }
    }

    // collisions: enemy bullets -> player
    const inv = cheat || player.invul>0;
    if(!inv){
      for(const b of eBullets){
        if(b.type==='LASER'){
          // laser is a line rotating from boss
          const a=b.a;
          const x2 = b.x + Math.cos(a)*900;
          const y2 = b.y + Math.sin(a)*900;
          // distance point to segment approx (player)
          const px=player.x, py=player.y;
          const vx=x2-b.x, vy=y2-b.y;
          const t = clamp(((px-b.x)*vx + (py-b.y)*vy)/(vx*vx+vy*vy), 0, 1);
          const cx = b.x + vx*t, cy = b.y + vy*t;
          if(dist2(px,py,cx,cy) < (player.r+10)*(player.r+10)){
            if(player.sh>0){ /* absorb */ }
            else { player.hp -= b.dmg*dt*3.0; }
            flash(0.05);
          }
          continue;
        }
        if(b.type==='HOM'){
          if(hitC(b.x,b.y,b.r,player.x,player.y,player.r)){
            b.life=0;
            if(player.sh>0){ flash(0.10); addParticle(b.x,b.y,14,280,0.4); }
            else { player.hp -= b.dmg; player.invul=0.55; shake(0.10,7); flash(0.18); addParticle(player.x,player.y,26,420,0.55); }
          }
          continue;
        }
        if(hitC(b.x,b.y,b.r,player.x,player.y,player.r)){
          b.life=0;
          if(player.sh>0){ addParticle(b.x,b.y,14,280,0.4); flash(0.10); }
          else { player.hp -= b.dmg; player.invul=0.55; shake(0.10,7); flash(0.18); addParticle(player.x,player.y,26,420,0.55); }
        }
      }
    }

    // collisions: enemy body -> player
    if(!inv){
      for(const e of enemies){
        if(e.hp<=0) continue;
        if(hitC(e.x,e.y,e.r,player.x,player.y,player.r+4)){
          e.hp=0;
          if(player.sh>0){ flash(0.10); }
          else { player.hp -= (e.type==='BOSS'? 40 : (e.type==='TANK'||e.type==='CARRIER'?26:18)); player.invul=0.8; shake(0.16,10); flash(0.22); }
          addParticle(e.x,e.y,34,480,0.6);
        }
      }
    }

    // pick drops
    for(const d of drops){
      if(hitC(d.x,d.y,d.r,player.x,player.y,player.r+10)){
        d.life=0;
        applyDrop(d.kind);
      }
    }

    // combo decay
    comboT -= dt;
    if(comboT<=0){ combo=1; comboT=0; }

    // upgrade triggers
    if(score >= nextUpgradeScore){
      showUpgradePick();
    }

    // cleanup dead enemies
    enemies = enemies.filter(e=>e.hp>0);

    // death
    if(player.hp<=0){
      running=false;
      flash(0.55); shake(0.35,14);
      addParticle(player.x,player.y,90,780,0.95);
      ui.modal.style.display='flex';
      ui.pickWrap.style.display='none';
      document.querySelector('#panel h2').textContent = 'Game Overï¼ˆç‚¹å¼€å§‹å†æ¥ï¼‰';
    }

    syncUI();
  }

  function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);

    // bg gradient
    const g=ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#050a18');
    g.addColorStop(1,'#02030a');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    // camera shake
    ctx.translate(camera.sx,camera.sy);

    // stars
    ctx.globalAlpha=0.9;
    for(const s of stars){
      ctx.fillStyle='rgba(200,225,255,0.55)';
      ctx.fillRect(s.x,s.y,s.s,s.s);
    }
    ctx.globalAlpha=1;

    // player glow
    const rg=ctx.createRadialGradient(player.x,player.y,0,player.x,player.y,140);
    rg.addColorStop(0,'rgba(90,170,255,0.18)');
    rg.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=rg; ctx.beginPath(); ctx.arc(player.x,player.y,140,0,Math.PI*2); ctx.fill();

    // player bullets
    for(const b of bullets){
      ctx.fillStyle='rgba(122,166,255,0.95)';
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha=0.28;
      ctx.fillRect(b.x-1,b.y,2,18);
      ctx.globalAlpha=1;
    }

    // enemies
    for(const e of enemies){
      // body
      ctx.fillStyle=e.col;
      ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill();

      // highlight
      ctx.globalAlpha=0.25;
      ctx.fillStyle='#fff';
      ctx.beginPath(); ctx.arc(e.x-e.r*0.22,e.y-e.r*0.22,e.r*0.36,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;

      // boss shield ring
      if(e.type==='BOSS' && e.shield>0){
        ctx.globalAlpha=0.55;
        ctx.strokeStyle='rgba(120,255,255,0.9)';
        ctx.lineWidth=3;
        ctx.beginPath(); ctx.arc(e.x,e.y,e.r+16,0,Math.PI*2); ctx.stroke();
        ctx.globalAlpha=1;
      }

      // hp bar
      const bw=e.r*2.4, bh=5;
      const bx=e.x-bw/2, by=e.y-e.r-12;
      ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(bx,by,bw,bh);
      ctx.fillStyle='rgba(90,255,170,.9)'; ctx.fillRect(bx,by,bw*(e.hp/e.hpMax),bh);

      if(e.type==='BOSS' && e.shield>0){
        ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect(bx,by-7,bw,4);
        ctx.fillStyle='rgba(140,220,255,.9)'; ctx.fillRect(bx,by-7,bw*(e.shield/240),4);
      }
    }

    // enemy bullets
    for(const b of eBullets){
      if(b.type==='LASER'){
        // draw laser beam
        ctx.globalAlpha=0.55;
        ctx.strokeStyle='rgba(255,90,160,0.95)';
        ctx.lineWidth=b.w;
        ctx.beginPath();
        ctx.moveTo(b.x,b.y);
        ctx.lineTo(b.x+Math.cos(b.a)*900, b.y+Math.sin(b.a)*900);
        ctx.stroke();
        ctx.globalAlpha=1;
        continue;
      }
      ctx.fillStyle='rgba(255,90,120,0.92)';
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r||4.2,0,Math.PI*2); ctx.fill();
    }

    // drops
    for(const d of drops){
      const map={POWER:'ğŸŸ¦',SHIELD:'ğŸŸ©',MISSILE:'ğŸŸ¨',ENERGY:'ğŸŸª',HP:'ğŸŸ¥'};
      ctx.font='18px system-ui';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(map[d.kind]||'ğŸŸ¦', d.x, d.y);
    }

    // particles
    ctx.fillStyle='rgba(255,255,255,0.75)';
    for(const p of particles){
      const a=Math.max(0,p.life/p.ttl);
      ctx.globalAlpha=a;
      ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha=1;

    // player ship
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.fillStyle='rgba(90,170,255,1)';
    ctx.beginPath();
    ctx.moveTo(0,-22); ctx.lineTo(16,14); ctx.lineTo(0,8); ctx.lineTo(-16,14);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle='rgba(122,210,255,0.9)';
    ctx.fillRect(-24,2,48,6);
    ctx.globalAlpha=0.85;
    ctx.fillStyle='rgba(255,170,80,0.9)';
    ctx.beginPath(); ctx.ellipse(0,18,6,10,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
    ctx.globalAlpha=1;

    // shield
    if(player.sh>0 || cheat){
      ctx.globalAlpha=cheat?0.55:0.35;
      ctx.strokeStyle='rgba(120,255,210,0.9)';
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(player.x,player.y,player.r+10,0,Math.PI*2); ctx.stroke();
      ctx.globalAlpha=1;
    }
    // invul
    if(player.invul>0 && !cheat){
      ctx.globalAlpha=0.18;
      ctx.fillStyle='#fff';
      ctx.beginPath(); ctx.arc(player.x,player.y,player.r+16,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha=1;
    }

    // overlay flash
    ctx.setTransform(1,0,0,1,0,0);
    for(const f of flashes){
      const a=(f.life/f.ttl)*f.a;
      ctx.fillStyle=`rgba(255,255,255,${a})`;
      ctx.fillRect(0,0,W,H);
    }

    // cheat label
    if(cheat){
      ctx.fillStyle='rgba(255,255,255,0.75)';
      ctx.font='12px system-ui';
      ctx.textAlign='left'; ctx.textBaseline='bottom';
      ctx.fillText('CHEAT MODE', 10, H-10);
    }
  }

  function loop(now){
    const dt=Math.min(0.033, (now-lastT)/1000);
    lastT=now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // start loop (menu visible initially)
  syncUI();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
